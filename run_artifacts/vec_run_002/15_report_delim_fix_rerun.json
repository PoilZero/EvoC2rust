{
    "macro": {
        "all_cnt": 2,
        "passed_cnt": 2,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 26,
        "passed_cnt": 20,
        "pass_rate": 0.7692307692307693,
        "messages": [
            {
                "c_code": "#define vec_t(T)                                                                                                       \\\n    struct                                                                                                             \\\n    {                                                                                                                  \\\n        T *data;                                                                                                       \\\n        int length, capacity;                                                                                          \\\n    }",
                "original_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060295866)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060296146)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_deinit(v) (free((v)->data), vec_init(v))",
                "original_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "optimized_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060296426)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060296704)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_sort(v, fn) qsort((v)->data, (v)->length, sizeof(*(v)->data), fn)",
                "original_rust_code": "pub(crate) macro_rules! vec_sort {\n    ($v:expr, $fn:expr) => {\n        qsort(\n            $v.data.cast(),\n            $v.length.cast(),\n            c_sizeof!(*$v.data),\n            $fn\n        )\n    }\n}",
                "optimized_rust_code": "pub(crate) macro_rules! vec_sort {\n    ($v:expr, $fn:expr) => {\n        qsort(\n            $v.data.cast(),\n            $v.length.cast(),\n            c_sizeof!(*$v.data),\n            $fn\n        )\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060297574)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:106:1\n    |\n106 | pub(crate) macro_rules! vec_sort {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n106 - pub(crate) macro_rules! vec_sort {\n106 + #[macro_export] macro_rules! vec_sort {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060297853)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:106:1\n    |\n106 | pub(crate) macro_rules! vec_sort {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n106 - pub(crate) macro_rules! vec_sort {\n106 + #[macro_export] macro_rules! vec_sort {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_truncate(v, len) ((v)->length = (len) < (v)->length ? (len) : (v)->length)",
                "original_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        let v = $v.cast();\n        let v_deref = v.deref();\n        v_deref.length = if $len < v_deref.length { $len } else { v_deref.length };\n    }\n}\npub(crate) use vec_truncate;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        let v = $v.cast();\n        let v_deref = v.deref();\n        v_deref.length = if $len < v_deref.length { $len } else { v_deref.length };\n    }\n}\npub(crate) use vec_truncate;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060298152)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:115:1\n    |\n115 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n115 - pub(crate) macro_rules! vec_truncate {\n115 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060298426)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:115:1\n    |\n115 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n115 - pub(crate) macro_rules! vec_truncate {\n115 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_reserve(v, n) vec_reserve_(vec_unpack_(v), n)",
                "original_rust_code": "pub(crate) macro_rules! vec_reserve {\n    ($v:expr, $n:expr) => {\n        vec_reserve_(vec_unpack_($v.cast()), $n)\n    };\n}\npub(crate) use vec_reserve;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_reserve {\n    ($v:expr, $n:expr) => {\n        vec_reserve_(vec_unpack_($v.cast()), $n)\n    };\n}\npub(crate) use vec_reserve;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060299005)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:132:1\n    |\n132 | pub(crate) macro_rules! vec_reserve {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n132 - pub(crate) macro_rules! vec_reserve {\n132 + #[macro_export] macro_rules! vec_reserve {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060299279)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:132:1\n    |\n132 | pub(crate) macro_rules! vec_reserve {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n132 - pub(crate) macro_rules! vec_reserve {\n132 + #[macro_export] macro_rules! vec_reserve {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_foreach_ptr(v, var, iter)                                                                                  \\\n    if ((v)->length > 0)                                                                                               \\\n        for ((iter) = 0; (iter) < (v)->length && (((var) = &(v)->data[(iter)]), 1); ++(iter))",
                "original_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            for iter in 0..$v.length {\n                $var = c_ref!($v.data[iter]).cast::<Ptr<u8>>();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            for iter in 0..$v.length {\n                $var = c_ref!($v.data[iter]).cast::<Ptr<u8>>();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060300593)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:225:1\n    |\n225 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n225 - pub(crate) macro_rules! vec_foreach_ptr {\n225 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060300877)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:225:1\n    |\n225 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n225 - pub(crate) macro_rules! vec_foreach_ptr {\n225 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "definition": {
        "all_cnt": 6,
        "passed_cnt": 4,
        "pass_rate": 0.6666666666666666,
        "messages": [
            {
                "c_code": "typedef vec_t(void *) vec_void_t;",
                "original_rust_code": "pub type VecVoidT = VecPtr<VoidPtr>;",
                "optimized_rust_code": "pub type VecVoidT = VecPtr<VoidPtr>;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060301162)\nerror[E0412]: cannot find type `VecPtr` in this scope\n  --> src/src/vec_h.rs:11:21\n   |\n11 | pub type VecVoidT = VecPtr<VoidPtr>;\n   |                     ^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060301447)\nerror[E0412]: cannot find type `VecPtr` in this scope\n  --> src/src/vec_h.rs:11:21\n   |\n11 | pub type VecVoidT = VecPtr<VoidPtr>;\n   |                     ^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "typedef vec_t(double) vec_double_t;",
                "original_rust_code": "pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;",
                "optimized_rust_code": "pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060302192)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:42\n    |\n27  | pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n    |                                          ^^^^\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n27  - pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n27  + pub type VecDoubleT = FuncPtr<fn(f64) -> Vec>;\n    |\nhelp: you might be missing a type parameter\n    |\n27  | pub type VecDoubleT<VecT> = FuncPtr<fn(f64) -> VecT>;\n    |                    ++++++\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060302491)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:42\n    |\n27  | pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n    |                                          ^^^^\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n27  - pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n27  + pub type VecDoubleT = FuncPtr<fn(f64) -> Vec>;\n    |\nhelp: you might be missing a type parameter\n    |\n27  | pub type VecDoubleT<VecT> = FuncPtr<fn(f64) -> VecT>;\n    |                    ++++++\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "dummy_function": {
        "all_cnt": 8,
        "passed_cnt": 8,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 8,
        "passed_cnt": 1,
        "pass_rate": 0.125,
        "messages": [
            {
                "c_code": "int vec_expand_(char **data, int *length, int *capacity, int memsz)\n{\n    if (*length + 1 > *capacity)\n    {\n        void *ptr;\n        int n = (*capacity == 0) ? 1 : *capacity << 1;\n        ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *data = ptr;\n        *capacity = n;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_expand_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32) -> i32 {\n    if (c_ref!(length).cast::<i32>() + 1 > c_ref!(capacity).cast::<i32>()) {\n        let mut ptr: Ptr<Void> = Default::default();\n        let mut n: i32 = if c_ref!(capacity).cast::<i32>() == 0 {\n            1\n        } else {\n            c_ref!(capacity).cast::<i32>() << 1\n        };\n        ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n        if (ptr == NULL!()) {\n            return -1;\n        }\n        c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n        c_ref!(capacity).cast() = n;\n    }\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_expand_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32) -> i32 {\n    if (c_ref!(length).cast::<i32>() + 1 > c_ref!(capacity).cast::<i32>()) {\n        let mut ptr: Ptr<Void> = Default::default();\n        let mut n: i32 = if c_ref!(capacity).cast::<i32>() == 0 {\n            1\n        } else {\n            c_ref!(capacity).cast::<i32>() << 1\n        };\n        ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n        if (ptr == NULL!()) {\n            return -1;\n        }\n        c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n        c_ref!(capacity).cast() = n;\n    }\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060303823)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:12:72\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n   |                                                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast::<T>());\n   |                                                                            +++++\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:16:29\n   |\n16 |         c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n   |         ------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:17:33\n   |\n17 |         c_ref!(capacity).cast() = n;\n   |         ----------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nSome errors have detailed explanations: E0070, E0282.\nFor more information about an error, try `rustc --explain E0070`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060304100)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:12:72\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n   |                                                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast::<T>());\n   |                                                                            +++++\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:16:29\n   |\n16 |         c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n   |         ------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:17:33\n   |\n17 |         c_ref!(capacity).cast() = n;\n   |         ----------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nSome errors have detailed explanations: E0070, E0282.\nFor more information about an error, try `rustc --explain E0070`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "int vec_reserve_(char **data, int *length, int *capacity, int memsz, int n)\n{\n    (void)length;\n    if (n > *capacity)\n    {\n        void *ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *data = ptr;\n        *capacity = n;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_reserve_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut n: i32) -> i32 {\n    let _ = length;\n    if (n > capacity.cast()).as_bool() {\n        let mut ptr: Ptr<Void> = c_realloc!(data, n * memsz);\n        if (ptr == NULL!()).as_bool() {\n            return -1;\n        }\n        data = ptr.cast();\n        capacity = n.cast();\n    }\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_reserve_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut n: i32) -> i32 {\n    let _ = length;\n    if (n > capacity.cast()).as_bool() {\n        let mut ptr: Ptr<Void> = c_realloc!(data, n * memsz);\n        if (ptr == NULL!()).as_bool() {\n            return -1;\n        }\n        data = ptr.cast();\n        capacity = n.cast();\n    }\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060304238)\nerror[E0277]: the trait bound `memory::ptr::Ptr<i32>: integer::Integer` is not satisfied\n   --> src/src/vec_c.rs:16:22\n    |\n16  |         capacity = n.cast();\n    |                      ^^^^ the trait `integer::Integer` is not implemented for `memory::ptr::Ptr<i32>`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<i32>` to implement `cast_trait::CastFrom<i32>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |                       -------  ^^^^^^^^^^^^     ^^\n    |                       |\n    |                       unsatisfied trait bound introduced here\nnote: required for `i32` to implement `cast_trait::CastInto<memory::ptr::Ptr<i32>>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060304531)\nerror[E0277]: the trait bound `memory::ptr::Ptr<i32>: integer::Integer` is not satisfied\n   --> src/src/vec_c.rs:16:22\n    |\n16  |         capacity = n.cast();\n    |                      ^^^^ the trait `integer::Integer` is not implemented for `memory::ptr::Ptr<i32>`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<i32>` to implement `cast_trait::CastFrom<i32>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |                       -------  ^^^^^^^^^^^^     ^^\n    |                       |\n    |                       unsatisfied trait bound introduced here\nnote: required for `i32` to implement `cast_trait::CastInto<memory::ptr::Ptr<i32>>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int vec_compact_(char **data, int *length, int *capacity, int memsz)\n{\n    if (*length == 0)\n    {\n        free(*data);\n        *data = NULL;\n        *capacity = 0;\n        return 0;\n    }\n    else\n    {\n        void *ptr;\n        int n = *length;\n        ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *capacity = n;\n        *data = ptr;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_compact_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, memsz: i32) -> i32 {\n    if ((*length).cast() == 0).as_bool() {\n        c_free!((*data).cast::<Ptr<Void>>());\n        *data = NULL!();\n        *capacity = 0;\n        return 0;\n    }\n\n    let n = (*length).cast();\n    let new_size = n * memsz as usize;\n\n    let ptr = c_realloc!((*data).cast(), new_size);\n    if ptr == NULL!() {\n        return -1;\n    }\n\n    *data = ptr.cast::<Ptr<u8>>();\n    *capacity = n;\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_compact_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, memsz: i32) -> i32 {\n    if ((*length).cast() == 0).as_bool() {\n        c_free!((*data).cast::<Ptr<Void>>());\n        *data = NULL!();\n        *capacity = 0;\n        return 0;\n    }\n\n    let n = (*length).cast();\n    let new_size = n * memsz as usize;\n\n    let ptr = c_realloc!((*data).cast(), new_size);\n    if ptr == NULL!() {\n        return -1;\n    }\n\n    *data = ptr.cast::<Ptr<u8>>();\n    *capacity = n;\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060304825)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:34:34\n   |\n34 |     let ptr = c_realloc!((*data).cast(), new_size);\n   |                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n34 |     let ptr = c_realloc!((*data).cast::<T>(), new_size);\n   |                                      +++++\n\nerror[E0277]: cannot multiply `i32` by `usize`\n  --> src/src/vec_c.rs:32:22\n   |\n32 |     let new_size = n * memsz as usize;\n   |                      ^ no implementation for `i32 * usize`\n   |\n   = help: the trait `std::ops::Mul<usize>` is not implemented for `i32`\n   = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n             `&i32` implements `std::ops::Mul<i32>`\n             `&i32` implements `std::ops::Mul`\n             `i32` implements `std::ops::Mul<&i32>`\n             `i32` implements `std::ops::Mul<types::num::Num>`\n             `i32` implements `std::ops::Mul`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/vec_c.rs:35:15\n    |\n35  |     if ptr == NULL!() {\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060305115)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:34:34\n   |\n34 |     let ptr = c_realloc!((*data).cast(), new_size);\n   |                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n34 |     let ptr = c_realloc!((*data).cast::<T>(), new_size);\n   |                                      +++++\n\nerror[E0277]: cannot multiply `i32` by `usize`\n  --> src/src/vec_c.rs:32:22\n   |\n32 |     let new_size = n * memsz as usize;\n   |                      ^ no implementation for `i32 * usize`\n   |\n   = help: the trait `std::ops::Mul<usize>` is not implemented for `i32`\n   = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n             `&i32` implements `std::ops::Mul<i32>`\n             `&i32` implements `std::ops::Mul`\n             `i32` implements `std::ops::Mul<&i32>`\n             `i32` implements `std::ops::Mul<types::num::Num>`\n             `i32` implements `std::ops::Mul`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/vec_c.rs:35:15\n    |\n35  |     if ptr == NULL!() {\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "int vec_insert_(char **data, int *length, int *capacity, int memsz, int idx)\n{\n    int err = vec_expand_(data, length, capacity, memsz);\n    if (err)\n        return err;\n    memmove(*data + (idx + 1) * memsz, *data + idx * memsz, (*length - idx) * memsz);\n    return 0;\n}",
                "original_rust_code": "pub fn vec_insert_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx: i32) -> i32 {\n    let mut err: i32 = vec_expand_(data.cast(), length.cast(), capacity.cast(), memsz);\n    if err != 0 {\n        return err;\n    }\n    c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_insert_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx: i32) -> i32 {\n    let mut err: i32 = vec_expand_(data.cast(), length.cast(), capacity.cast(), memsz);\n    if err != 0 {\n        return err;\n    }\n    c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060305262)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:32:94\n   |\n32 |     c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n   |                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060305548)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:32:94\n   |\n32 |     c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n   |                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_splice_(char **data, int *length, int *capacity, int memsz, int start, int count)\n{\n    (void)capacity;\n    memmove(*data + start * memsz, *data + (start + count) * memsz, (*length - start - count) * memsz);\n}",
                "original_rust_code": "pub fn vec_splice_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut start: i32, mut count: i32) {\n    let _ = capacity;\n    c_memmove!(\n        (c_ref!(data).cast::<Ptr<u8>>() + start * memsz).cast(),\n        (c_ref!(data).cast::<Ptr<u8>>() + (start + count) * memsz).cast(),\n        ((length.cast() - start - count) * memsz).cast::<usize>()\n    );\n}",
                "optimized_rust_code": "pub fn vec_splice_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut start: i32, mut count: i32) {\n    let _ = capacity;\n    c_memmove!(\n        (c_ref!(data).cast::<Ptr<u8>>() + start * memsz).cast(),\n        (c_ref!(data).cast::<Ptr<u8>>() + (start + count) * memsz).cast(),\n        ((length.cast() - start - count) * memsz).cast::<usize>()\n    );\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060305683)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:36:9\n   |\n36 |         ((length.cast() - start - count) * memsz).cast::<usize>()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060305961)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:36:9\n   |\n36 |         ((length.cast() - start - count) * memsz).cast::<usize>()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_swapsplice_(char **data, int *length, int *capacity, int memsz, int start, int count)\n{\n    (void)capacity;\n    memmove(*data + start * memsz, *data + (*length - count) * memsz, count * memsz);\n}",
                "original_rust_code": "pub fn vec_swapsplice_(\n    mut data: Ptr<Ptr<u8>>,\n    mut length: Ptr<i32>,\n    mut capacity: Ptr<i32>,\n    mut memsz: i32,\n    mut start: i32,\n    mut count: i32\n) {\n    let _ = capacity;\n    c_memmove!(\n        (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n        (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast(),\n        count * memsz\n    );\n}",
                "optimized_rust_code": "pub fn vec_swapsplice_(\n    mut data: Ptr<Ptr<u8>>,\n    mut length: Ptr<i32>,\n    mut capacity: Ptr<i32>,\n    mut memsz: i32,\n    mut start: i32,\n    mut count: i32\n) {\n    let _ = capacity;\n    c_memmove!(\n        (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n        (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast(),\n        count * memsz\n    );\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060306098)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:50\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n   |                                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast::<T>(),\n   |                                                      +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060306384)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:50\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n   |                                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast::<T>(),\n   |                                                      +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_swap_(char **data, int *length, int *capacity, int memsz, int idx1, int idx2)\n{\n    unsigned char *a, *b, tmp;\n    int count;\n    (void)length;\n    (void)capacity;\n    if (idx1 == idx2)\n        return;\n    a = (unsigned char *)*data + idx1 * memsz;\n    b = (unsigned char *)*data + idx2 * memsz;\n    count = memsz;\n    while (count--)\n    {\n        tmp = *a;\n        *a = *b;\n        *b = tmp;\n        a++, b++;\n    }\n}",
                "original_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz).cast();\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "optimized_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz).cast();\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060306521)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:27\n   |\n45 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz).cast();\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060306799)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:27\n   |\n45 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz).cast();\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    }
}
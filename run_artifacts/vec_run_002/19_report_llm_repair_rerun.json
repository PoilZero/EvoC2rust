{
    "macro": {
        "all_cnt": 2,
        "passed_cnt": 2,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 26,
        "passed_cnt": 20,
        "pass_rate": 0.7692307692307693,
        "messages": [
            {
                "c_code": "#define vec_t(T)                                                                                                       \\\n    struct                                                                                                             \\\n    {                                                                                                                  \\\n        T *data;                                                                                                       \\\n        int length, capacity;                                                                                          \\\n    }",
                "original_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060378558)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060378558)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_deinit(v) (free((v)->data), vec_init(v))",
                "original_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "optimized_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060378846)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060378846)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_sort(v, fn) qsort((v)->data, (v)->length, sizeof(*(v)->data), fn)",
                "original_rust_code": "pub(crate) macro_rules! vec_sort {\n    ($v:expr, $fn:expr) => {\n        qsort(\n            $v.data.cast(),\n            $v.length.cast(),\n            c_sizeof!(*$v.data),\n            $fn\n        )\n    }\n}",
                "optimized_rust_code": "pub(crate) macro_rules! vec_sort {\n    ($v:expr, $fn:expr) => {\n        qsort(\n            $v.data.cast(),\n            $v.length.cast(),\n            c_sizeof!(*$v.data),\n            $fn\n        )\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060379720)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:106:1\n    |\n106 | pub(crate) macro_rules! vec_sort {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n106 - pub(crate) macro_rules! vec_sort {\n106 + #[macro_export] macro_rules! vec_sort {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060379720)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:106:1\n    |\n106 | pub(crate) macro_rules! vec_sort {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n106 - pub(crate) macro_rules! vec_sort {\n106 + #[macro_export] macro_rules! vec_sort {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_truncate(v, len) ((v)->length = (len) < (v)->length ? (len) : (v)->length)",
                "original_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        let v = $v.cast();\n        let v_deref = v.deref();\n        v_deref.length = if $len < v_deref.length { $len } else { v_deref.length };\n    }\n}\npub(crate) use vec_truncate;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        let v = $v.cast();\n        let v_deref = v.deref();\n        v_deref.length = if $len < v_deref.length { $len } else { v_deref.length };\n    }\n}\npub(crate) use vec_truncate;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060380013)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:115:1\n    |\n115 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n115 - pub(crate) macro_rules! vec_truncate {\n115 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060380013)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:115:1\n    |\n115 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n115 - pub(crate) macro_rules! vec_truncate {\n115 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_reserve(v, n) vec_reserve_(vec_unpack_(v), n)",
                "original_rust_code": "pub(crate) macro_rules! vec_reserve {\n    ($v:expr, $n:expr) => {\n        vec_reserve_(vec_unpack_($v.cast()), $n)\n    };\n}\npub(crate) use vec_reserve;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_reserve {\n    ($v:expr, $n:expr) => {\n        vec_reserve_(vec_unpack_($v.cast()), $n)\n    };\n}\npub(crate) use vec_reserve;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060380584)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:132:1\n    |\n132 | pub(crate) macro_rules! vec_reserve {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n132 - pub(crate) macro_rules! vec_reserve {\n132 + #[macro_export] macro_rules! vec_reserve {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060380584)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:132:1\n    |\n132 | pub(crate) macro_rules! vec_reserve {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n132 - pub(crate) macro_rules! vec_reserve {\n132 + #[macro_export] macro_rules! vec_reserve {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_foreach_ptr(v, var, iter)                                                                                  \\\n    if ((v)->length > 0)                                                                                               \\\n        for ((iter) = 0; (iter) < (v)->length && (((var) = &(v)->data[(iter)]), 1); ++(iter))",
                "original_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            for iter in 0..$v.length {\n                $var = c_ref!($v.data[iter]).cast::<Ptr<u8>>();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            for iter in 0..$v.length {\n                $var = c_ref!($v.data[iter]).cast::<Ptr<u8>>();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060381896)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:225:1\n    |\n225 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n225 - pub(crate) macro_rules! vec_foreach_ptr {\n225 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060381896)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:225:1\n    |\n225 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n225 - pub(crate) macro_rules! vec_foreach_ptr {\n225 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "definition": {
        "all_cnt": 6,
        "passed_cnt": 4,
        "pass_rate": 0.6666666666666666,
        "messages": [
            {
                "c_code": "typedef vec_t(void *) vec_void_t;",
                "original_rust_code": "pub type VecVoidT = VecPtr<VoidPtr>;",
                "optimized_rust_code": "pub type VecVoidT = VecPtr<VoidPtr>;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060382177)\nerror[E0412]: cannot find type `VecPtr` in this scope\n  --> src/src/vec_h.rs:11:21\n   |\n11 | pub type VecVoidT = VecPtr<VoidPtr>;\n   |                     ^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060382177)\nerror[E0412]: cannot find type `VecPtr` in this scope\n  --> src/src/vec_h.rs:11:21\n   |\n11 | pub type VecVoidT = VecPtr<VoidPtr>;\n   |                     ^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "typedef vec_t(double) vec_double_t;",
                "original_rust_code": "pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;",
                "optimized_rust_code": "pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060382902)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:42\n    |\n27  | pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n    |                                          ^^^^\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n27  - pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n27  + pub type VecDoubleT = FuncPtr<fn(f64) -> Vec>;\n    |\nhelp: you might be missing a type parameter\n    |\n27  | pub type VecDoubleT<VecT> = FuncPtr<fn(f64) -> VecT>;\n    |                    ++++++\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060382902)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:42\n    |\n27  | pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n    |                                          ^^^^\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n    |\nhelp: a struct with a similar name exists\n    |\n27  - pub type VecDoubleT = FuncPtr<fn(f64) -> VecT>;\n27  + pub type VecDoubleT = FuncPtr<fn(f64) -> Vec>;\n    |\nhelp: you might be missing a type parameter\n    |\n27  | pub type VecDoubleT<VecT> = FuncPtr<fn(f64) -> VecT>;\n    |                    ++++++\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "dummy_function": {
        "all_cnt": 8,
        "passed_cnt": 8,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 8,
        "passed_cnt": 3,
        "pass_rate": 0.375,
        "messages": [
            {
                "c_code": "int vec_expand_(char **data, int *length, int *capacity, int memsz)\n{\n    if (*length + 1 > *capacity)\n    {\n        void *ptr;\n        int n = (*capacity == 0) ? 1 : *capacity << 1;\n        ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *data = ptr;\n        *capacity = n;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_expand_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32) -> i32 {\n    if (c_ref!(length).cast::<i32>() + 1 > c_ref!(capacity).cast::<i32>()) {\n        let mut ptr: Ptr<Void> = Default::default();\n        let mut n: i32 = if c_ref!(capacity).cast::<i32>() == 0 {\n            1\n        } else {\n            c_ref!(capacity).cast::<i32>() << 1\n        };\n        ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz));\n        if (ptr == NULL!()) {\n            return -1;\n        }\n        c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n        c_ref!(capacity).cast() = n;\n    }\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_expand_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32) -> i32 {\n    if (c_ref!(length).cast::<i32>() + 1 > c_ref!(capacity).cast::<i32>()) {\n        let mut ptr: Ptr<Void> = Default::default();\n        let mut n: i32 = if c_ref!(capacity).cast::<i32>() == 0 {\n            1\n        } else {\n            c_ref!(capacity).cast::<i32>() << 1\n        };\n        ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz));\n        if (ptr == NULL!()) {\n            return -1;\n        }\n        c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n        c_ref!(capacity).cast() = n;\n    }\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060384233)\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:16:29\n   |\n16 |         c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n   |         ------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:17:33\n   |\n17 |         c_ref!(capacity).cast() = n;\n   |         ----------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nFor more information about this error, try `rustc --explain E0070`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060641387)\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:16:29\n   |\n16 |         c_ref!(data).cast() = ptr.cast::<Ptr<u8>>();\n   |         ------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:17:33\n   |\n17 |         c_ref!(capacity).cast() = n;\n   |         ----------------------- ^\n   |         |\n   |         cannot assign to this expression\n\nFor more information about this error, try `rustc --explain E0070`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "int vec_compact_(char **data, int *length, int *capacity, int memsz)\n{\n    if (*length == 0)\n    {\n        free(*data);\n        *data = NULL;\n        *capacity = 0;\n        return 0;\n    }\n    else\n    {\n        void *ptr;\n        int n = *length;\n        ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *capacity = n;\n        *data = ptr;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_compact_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, memsz: i32) -> i32 {\n    if ((*length) == 0) {\n        c_free!((*data).cast::<Ptr<Void>>());\n        *data = NULL!();\n        *capacity = 0;\n        return 0;\n    }\n\n    let n = (*length);\n    let new_size = n * memsz as usize;\n\n    let ptr = c_realloc!((*data), new_size);\n    if ptr == NULL!() {\n        return -1;\n    }\n\n    *data = ptr.cast::<Ptr<u8>>();\n    *capacity = n;\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_compact_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, memsz: i32) -> i32 {\n    if ((*length) == 0) {\n        c_free!((*data).cast::<Ptr<Void>>());\n        *data = NULL!();\n        *capacity = 0;\n        return 0;\n    }\n\n    let n = (*length);\n    let new_size = (n * memsz) as usize; // Fixed: Multiply i32 values first, then cast to usize\n\n    let ptr: Ptr<Void> = c_realloc!((*data), new_size);\n    if ptr.is_null() {\n        return -1;\n    }\n\n    *data = ptr.cast::<Ptr<u8>>();\n    *capacity = n;\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060664883)\nerror[E0308]: mismatched types\n  --> src/src/vec_c.rs:41:24\n   |\n41 |     let new_size = n * memsz as usize;\n   |                        ^^^^^^^^^^^^^^ expected `i32`, found `usize`\n\nerror[E0277]: cannot multiply `i32` by `usize`\n  --> src/src/vec_c.rs:41:22\n   |\n41 |     let new_size = n * memsz as usize;\n   |                      ^ no implementation for `i32 * usize`\n   |\n   = help: the trait `std::ops::Mul<usize>` is not implemented for `i32`\n   = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n             `&i32` implements `std::ops::Mul<i32>`\n             `&i32` implements `std::ops::Mul`\n             `i32` implements `std::ops::Mul<&i32>`\n             `i32` implements `std::ops::Mul<types::num::Num>`\n             `i32` implements `std::ops::Mul`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/vec_c.rs:44:15\n    |\n44  |     if ptr == NULL!() {\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060917502)\nerror[E0599]: no method named `is_null` found for struct `memory::ptr::Ptr<u8>` in the current scope\n  --> src/src/vec_c.rs:44:12\n   |\n44 |     if ptr.is_null() {\n   |            ^^^^^^^ method not found in `memory::ptr::Ptr<u8>`\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `is_null` not found for this struct\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int vec_insert_(char **data, int *length, int *capacity, int memsz, int idx)\n{\n    int err = vec_expand_(data, length, capacity, memsz);\n    if (err)\n        return err;\n    memmove(*data + (idx + 1) * memsz, *data + idx * memsz, (*length - idx) * memsz);\n    return 0;\n}",
                "original_rust_code": "pub fn vec_insert_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx: i32) -> i32 {\n    let mut err: i32 = vec_expand_(data, length, capacity, memsz);\n    if err != 0 {\n        return err;\n    }\n    c_memmove!((data + (idx + 1) * memsz), (data + idx * memsz), ((length.cast() - idx) * memsz).cast::<u32>());\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_insert_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx: i32) -> i32 {\n    let mut err: i32 = vec_expand_(data, length, capacity, memsz);\n    if err != 0 {\n        return err;\n    }\n    c_memmove!((data + (idx + 1) * memsz), (data + idx * memsz), ((length.cast() - idx) as u32 * memsz as u32));\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769060917649)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:41:66\n   |\n41 |     c_memmove!((data + (idx + 1) * memsz), (data + idx * memsz), ((length.cast() - idx) * memsz).cast::<u32>());\n   |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769061330206)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:41:67\n   |\n41 |     c_memmove!((data + (idx + 1) * memsz), (data + idx * memsz), ((length.cast() - idx) as u32 * memsz as u32));\n   |                                                                   ^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_swapsplice_(char **data, int *length, int *capacity, int memsz, int start, int count)\n{\n    (void)capacity;\n    memmove(*data + start * memsz, *data + (*length - count) * memsz, count * memsz);\n}",
                "original_rust_code": "pub fn vec_swapsplice_(\n    mut data: Ptr<Ptr<u8>>,\n    mut length: Ptr<i32>,\n    mut capacity: Ptr<i32>,\n    mut memsz: i32,\n    mut start: i32,\n    mut count: i32\n) {\n    let _ = capacity;\n    c_memmove!(\n        (data.cast::<Ptr<u8>>() + start * memsz),\n        (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast(),\n        count * memsz\n    );\n}",
                "optimized_rust_code": "pub fn vec_swapsplice_(\n    mut data: Ptr<Ptr<u8>>,\n    mut length: Ptr<i32>,\n    mut capacity: Ptr<i32>,\n    mut memsz: i32,\n    mut start: i32,\n    mut count: i32\n) {\n    let _ = capacity;\n    c_memmove!(\n        (data.cast::<Ptr<u8>>() + start * memsz),\n        (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast(),\n        count * memsz\n    );\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769061374914)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:60:68\n   |\n60 |         (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast(),\n   |                                                                    ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n60 |         (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast::<T>(),\n   |                                                                        +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769061628413)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:60:68\n   |\n60 |         (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast(),\n   |                                                                    ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n60 |         (data.cast::<Ptr<u8>>() + (length.cast() - count) * memsz).cast::<T>(),\n   |                                                                        +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_swap_(char **data, int *length, int *capacity, int memsz, int idx1, int idx2)\n{\n    unsigned char *a, *b, tmp;\n    int count;\n    (void)length;\n    (void)capacity;\n    if (idx1 == idx2)\n        return;\n    a = (unsigned char *)*data + idx1 * memsz;\n    b = (unsigned char *)*data + idx2 * memsz;\n    count = memsz;\n    while (count--)\n    {\n        tmp = *a;\n        *a = *b;\n        *b = tmp;\n        a++, b++;\n    }\n}",
                "original_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz);\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "optimized_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz);\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769061628555)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:59:27\n   |\n59 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n59 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz);\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_002_1769061886355)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:59:27\n   |\n59 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n59 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz);\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    }
}
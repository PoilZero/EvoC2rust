{
    "macro": {
        "all_cnt": 2,
        "passed_cnt": 2,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 26,
        "passed_cnt": 20,
        "pass_rate": 0.7692307692307693,
        "messages": [
            {
                "c_code": "#define vec_t(T)                                                                                                       \\\n    struct                                                                                                             \\\n    {                                                                                                                  \\\n        T *data;                                                                                                       \\\n        int length, capacity;                                                                                          \\\n    }",
                "original_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066881395)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066881679)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_deinit(v) (free((v)->data), vec_init(v))",
                "original_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "optimized_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066881982)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066882271)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_truncate(v, len) ((v)->length = (len) < (v)->length ? (len) : (v)->length)",
                "original_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        $v.cast().length = if $len < $v.cast().length { $len } else { $v.cast().length };\n    };\n}\npub(crate) use vec_truncate;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        $v.cast().length = if $len < $v.cast().length { $len } else { $v.cast().length };\n    };\n}\npub(crate) use vec_truncate;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066883463)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:119:1\n    |\n119 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n119 - pub(crate) macro_rules! vec_truncate {\n119 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066883755)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:119:1\n    |\n119 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n119 - pub(crate) macro_rules! vec_truncate {\n119 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_pusharr(v, arr, count)                                                                                     \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        int i__, n__ = (count);                                                                                        \\\n        if (vec_reserve_po2_(vec_unpack_(v), (v)->length + n__) != 0)                                                  \\\n            break;                                                                                                     \\\n        for (i__ = 0; i__ < n__; i__++)                                                                                \\\n        {                                                                                                              \\\n            (v)->data[(v)->length++] = (arr)[i__];                                                                     \\\n        }                                                                                                              \\\n    } while (0)",
                "original_rust_code": "pub(crate) macro_rules! vec_pusharr {\n    ($v:expr, $arr:expr, $count:expr) => {\n        let mut i__: i32;\n        let n__: i32 = $count;\n\n        if vec_reserve_po2_(vec_unpack_($v.cast()), $v.length + n__) != 0 {\n            break;\n        }\n\n        for i__ in 0..n__ {\n            let idx = $v.length;\n            $v.data[idx] = $arr[i__] as u8;\n            $v.length = $v.length.plus_plus();\n        }\n    }\n}\npub(crate) use vec_pusharr;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_pusharr {\n    ($v:expr, $arr:expr, $count:expr) => {\n        let mut i__: i32;\n        let n__: i32 = $count;\n\n        if vec_reserve_po2_(vec_unpack_($v.cast()), $v.length + n__) != 0 {\n            break;\n        }\n\n        for i__ in 0..n__ {\n            let idx = $v.length;\n            $v.data[idx] = $arr[i__] as u8;\n            $v.length = $v.length.plus_plus();\n        }\n    }\n}\npub(crate) use vec_pusharr;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066884668)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:147:1\n    |\n147 | pub(crate) macro_rules! vec_pusharr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n147 - pub(crate) macro_rules! vec_pusharr {\n147 + #[macro_export] macro_rules! vec_pusharr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066884955)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:147:1\n    |\n147 | pub(crate) macro_rules! vec_pusharr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n147 - pub(crate) macro_rules! vec_pusharr {\n147 + #[macro_export] macro_rules! vec_pusharr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_remove(v, val)                                                                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        int idx__;                                                                                                     \\\n        vec_find(v, val, idx__);                                                                                       \\\n        if (idx__ != -1)                                                                                               \\\n            vec_splice(v, idx__, 1);                                                                                   \\\n    } while (0)",
                "original_rust_code": "pub(crate) macro_rules! vec_remove {\n    ($v:expr, $val:expr) => {\n        let mut idx__: i32;\n        vec_find($v.cast(), $val.cast(), idx__.cast());\n        if idx__ != -1 {\n            vec_splice($v.cast(), idx__.cast(), 1.cast());\n        }\n    };\n}\npub(crate) use vec_remove;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_remove {\n    ($v:expr, $val:expr) => {\n        let mut idx__: i32;\n        vec_find($v.cast(), $val.cast(), idx__.cast());\n        if idx__ != -1 {\n            vec_splice($v.cast(), idx__.cast(), 1.cast());\n        }\n    };\n}\npub(crate) use vec_remove;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066885407)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:170:1\n    |\n170 | pub(crate) macro_rules! vec_remove {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n170 - pub(crate) macro_rules! vec_remove {\n170 + #[macro_export] macro_rules! vec_remove {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066885696)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:170:1\n    |\n170 | pub(crate) macro_rules! vec_remove {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n170 - pub(crate) macro_rules! vec_remove {\n170 + #[macro_export] macro_rules! vec_remove {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_foreach_ptr(v, var, iter)                                                                                  \\\n    if ((v)->length > 0)                                                                                               \\\n        for ((iter) = 0; (iter) < (v)->length && (((var) = &(v)->data[(iter)]), 1); ++(iter))",
                "original_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            let mut iter = 0;\n            while iter < $v.length {\n                $var = c_ref!($v.data[iter]);\n                iter = iter.plus_plus();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            let mut iter = 0;\n            while iter < $v.length {\n                $var = c_ref!($v.data[iter]);\n                iter = iter.plus_plus();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066886296)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:202:1\n    |\n202 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n202 - pub(crate) macro_rules! vec_foreach_ptr {\n202 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066886592)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:202:1\n    |\n202 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n202 - pub(crate) macro_rules! vec_foreach_ptr {\n202 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "definition": {
        "all_cnt": 6,
        "passed_cnt": 5,
        "pass_rate": 0.8333333333333334,
        "messages": [
            {
                "c_code": "typedef vec_t(double) vec_double_t;",
                "original_rust_code": "pub type VecDoubleT = fn(f64) -> VecT;",
                "optimized_rust_code": "pub type VecDoubleT = fn(f64) -> VecT;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066887642)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:34\n    |\n27  | pub type VecDoubleT = fn(f64) -> VecT;\n    |                                  ^^^^ help: a struct with a similar name exists: `Vec`\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066887942)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:34\n    |\n27  | pub type VecDoubleT = fn(f64) -> VecT;\n    |                                  ^^^^ help: a struct with a similar name exists: `Vec`\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "dummy_function": {
        "all_cnt": 8,
        "passed_cnt": 8,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 8,
        "passed_cnt": 1,
        "pass_rate": 0.125,
        "messages": [
            {
                "c_code": "int vec_expand_(char **data, int *length, int *capacity, int memsz)\n{\n    if (*length + 1 > *capacity)\n    {\n        void *ptr;\n        int n = (*capacity == 0) ? 1 : *capacity << 1;\n        ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *data = ptr;\n        *capacity = n;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_expand_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32) -> i32 {\n    if (c_ref!(length).cast::<i32>() + 1 > c_ref!(capacity).cast::<i32>()) {\n        let mut ptr: Ptr<Void> = Default::default();\n        let mut n: i32 = if c_ref!(capacity).cast::<i32>() == 0 {\n            1\n        } else {\n            c_ref!(capacity).cast::<i32>() << 1\n        };\n        ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n        if (ptr == NULL!()) {\n            return -1;\n        }\n        c_ref!(data).cast::<Ptr<u8>>() = ptr.cast::<Ptr<u8>>();\n        c_ref!(capacity).cast::<i32>() = n;\n    }\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_expand_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32) -> i32 {\n    if (c_ref!(length).cast::<i32>() + 1 > c_ref!(capacity).cast::<i32>()) {\n        let mut ptr: Ptr<Void> = Default::default();\n        let mut n: i32 = if c_ref!(capacity).cast::<i32>() == 0 {\n            1\n        } else {\n            c_ref!(capacity).cast::<i32>() << 1\n        };\n        ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n        if (ptr == NULL!()) {\n            return -1;\n        }\n        c_ref!(data).cast::<Ptr<u8>>() = ptr.cast::<Ptr<u8>>();\n        c_ref!(capacity).cast::<i32>() = n;\n    }\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066889331)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:12:72\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n   |                                                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast::<T>());\n   |                                                                            +++++\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:16:40\n   |\n16 |         c_ref!(data).cast::<Ptr<u8>>() = ptr.cast::<Ptr<u8>>();\n   |         ------------------------------ ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:17:40\n   |\n17 |         c_ref!(capacity).cast::<i32>() = n;\n   |         ------------------------------ ^\n   |         |\n   |         cannot assign to this expression\n\nSome errors have detailed explanations: E0070, E0282.\nFor more information about an error, try `rustc --explain E0070`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066889622)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:12:72\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast());\n   |                                                                        ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n12 |         ptr = c_realloc!(c_ref!(data).cast::<Ptr<Void>>(), (n * memsz).cast::<T>());\n   |                                                                            +++++\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:16:40\n   |\n16 |         c_ref!(data).cast::<Ptr<u8>>() = ptr.cast::<Ptr<u8>>();\n   |         ------------------------------ ^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of assignment\n  --> src/src/vec_c.rs:17:40\n   |\n17 |         c_ref!(capacity).cast::<i32>() = n;\n   |         ------------------------------ ^\n   |         |\n   |         cannot assign to this expression\n\nSome errors have detailed explanations: E0070, E0282.\nFor more information about an error, try `rustc --explain E0070`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "int vec_reserve_(char **data, int *length, int *capacity, int memsz, int n)\n{\n    (void)length;\n    if (n > *capacity)\n    {\n        void *ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *data = ptr;\n        *capacity = n;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_reserve_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut n: i32) -> i32 {\n    let _ = length;\n    if (n > capacity.cast()).as_bool() {\n        let mut ptr: Ptr<Void> = c_realloc!(data, n * memsz);\n        if (ptr == NULL!()).as_bool() {\n            return -1;\n        }\n        data = ptr.cast();\n        capacity = n.cast();\n    }\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_reserve_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut n: i32) -> i32 {\n    let _ = length;\n    if (n > capacity.cast()).as_bool() {\n        let mut ptr: Ptr<Void> = c_realloc!(data, n * memsz);\n        if (ptr == NULL!()).as_bool() {\n            return -1;\n        }\n        data = ptr.cast();\n        capacity = n.cast();\n    }\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066889763)\nerror[E0277]: the trait bound `memory::ptr::Ptr<i32>: integer::Integer` is not satisfied\n   --> src/src/vec_c.rs:16:22\n    |\n16  |         capacity = n.cast();\n    |                      ^^^^ the trait `integer::Integer` is not implemented for `memory::ptr::Ptr<i32>`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<i32>` to implement `cast_trait::CastFrom<i32>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |                       -------  ^^^^^^^^^^^^     ^^\n    |                       |\n    |                       unsatisfied trait bound introduced here\nnote: required for `i32` to implement `cast_trait::CastInto<memory::ptr::Ptr<i32>>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066890068)\nerror[E0277]: the trait bound `memory::ptr::Ptr<i32>: integer::Integer` is not satisfied\n   --> src/src/vec_c.rs:16:22\n    |\n16  |         capacity = n.cast();\n    |                      ^^^^ the trait `integer::Integer` is not implemented for `memory::ptr::Ptr<i32>`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `memory::ptr::Ptr<i32>` to implement `cast_trait::CastFrom<i32>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |                       -------  ^^^^^^^^^^^^     ^^\n    |                       |\n    |                       unsatisfied trait bound introduced here\nnote: required for `i32` to implement `cast_trait::CastInto<memory::ptr::Ptr<i32>>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int vec_compact_(char **data, int *length, int *capacity, int memsz)\n{\n    if (*length == 0)\n    {\n        free(*data);\n        *data = NULL;\n        *capacity = 0;\n        return 0;\n    }\n    else\n    {\n        void *ptr;\n        int n = *length;\n        ptr = realloc(*data, n * memsz);\n        if (ptr == NULL)\n            return -1;\n        *capacity = n;\n        *data = ptr;\n    }\n    return 0;\n}",
                "original_rust_code": "pub fn vec_compact_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, memsz: i32) -> i32 {\n    if ((*length).cast() == 0).as_bool() {\n        c_free!((*data).cast::<Ptr<Void>>());\n        *data = NULL!();\n        *capacity = 0;\n        return 0;\n    }\n\n    let n = (*length).cast();\n    let new_size = n * memsz;\n\n    let ptr = c_realloc!((*data).cast::<Ptr<Void>>(), new_size as usize);\n    if ptr == NULL!() {\n        return -1;\n    }\n\n    *data = ptr.cast::<Ptr<u8>>();\n    *capacity = n;\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_compact_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, memsz: i32) -> i32 {\n    if ((*length).cast() == 0).as_bool() {\n        c_free!((*data).cast::<Ptr<Void>>());\n        *data = NULL!();\n        *capacity = 0;\n        return 0;\n    }\n\n    let n = (*length).cast();\n    let new_size = n * memsz;\n\n    let ptr = c_realloc!((*data).cast::<Ptr<Void>>(), new_size as usize);\n    if ptr == NULL!() {\n        return -1;\n    }\n\n    *data = ptr.cast::<Ptr<u8>>();\n    *capacity = n;\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066890382)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:34:9\n   |\n34 |     let ptr = c_realloc!((*data).cast::<Ptr<Void>>(), new_size as usize);\n   |         ^^^\n...\n39 |     *data = ptr.cast::<Ptr<u8>>();\n   |             --- type must be known at this point\n   |\nhelp: consider giving `ptr` an explicit type\n   |\n34 |     let ptr: /* Type */ = c_realloc!((*data).cast::<Ptr<Void>>(), new_size as usize);\n   |            ++++++++++++\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/vec_c.rs:35:15\n    |\n35  |     if ptr == NULL!() {\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066890712)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:34:9\n   |\n34 |     let ptr = c_realloc!((*data).cast::<Ptr<Void>>(), new_size as usize);\n   |         ^^^\n...\n39 |     *data = ptr.cast::<Ptr<u8>>();\n   |             --- type must be known at this point\n   |\nhelp: consider giving `ptr` an explicit type\n   |\n34 |     let ptr: /* Type */ = c_realloc!((*data).cast::<Ptr<Void>>(), new_size as usize);\n   |            ++++++++++++\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/vec_c.rs:35:15\n    |\n35  |     if ptr == NULL!() {\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0282.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "int vec_insert_(char **data, int *length, int *capacity, int memsz, int idx)\n{\n    int err = vec_expand_(data, length, capacity, memsz);\n    if (err)\n        return err;\n    memmove(*data + (idx + 1) * memsz, *data + idx * memsz, (*length - idx) * memsz);\n    return 0;\n}",
                "original_rust_code": "pub fn vec_insert_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx: i32) -> i32 {\n    let mut err: i32 = vec_expand_(data.cast(), length.cast(), capacity.cast(), memsz);\n    if err != 0 {\n        return err;\n    }\n    c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n    return 0;\n}",
                "optimized_rust_code": "pub fn vec_insert_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx: i32) -> i32 {\n    let mut err: i32 = vec_expand_(data.cast(), length.cast(), capacity.cast(), memsz);\n    if err != 0 {\n        return err;\n    }\n    c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n    return 0;\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066890873)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:32:94\n   |\n32 |     c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n   |                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066891196)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:32:94\n   |\n32 |     c_memmove!((data.cast() + (idx + 1) * memsz).cast(), (data.cast() + idx * memsz).cast(), ((length.cast() - idx) * memsz).cast::<u32>());\n   |                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_splice_(char **data, int *length, int *capacity, int memsz, int start, int count)\n{\n    (void)capacity;\n    memmove(*data + start * memsz, *data + (start + count) * memsz, (*length - start - count) * memsz);\n}",
                "original_rust_code": "pub fn vec_splice_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut start: i32, mut count: i32) {\n    let _ = capacity;\n    c_memmove!(\n        (c_ref!(data).cast::<Ptr<u8>>() + start * memsz).cast(),\n        (c_ref!(data).cast::<Ptr<u8>>() + (start + count) * memsz).cast(),\n        ((length.cast() - start - count) * memsz).cast::<usize>()\n    );\n}",
                "optimized_rust_code": "pub fn vec_splice_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut start: i32, mut count: i32) {\n    let _ = capacity;\n    c_memmove!(\n        (c_ref!(data).cast::<Ptr<u8>>() + start * memsz).cast(),\n        (c_ref!(data).cast::<Ptr<u8>>() + (start + count) * memsz).cast(),\n        ((length.cast() - start - count) * memsz).cast::<usize>()\n    );\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066891355)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:36:9\n   |\n36 |         ((length.cast() - start - count) * memsz).cast::<usize>()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066891650)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:36:9\n   |\n36 |         ((length.cast() - start - count) * memsz).cast::<usize>()\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_swapsplice_(char **data, int *length, int *capacity, int memsz, int start, int count)\n{\n    (void)capacity;\n    memmove(*data + start * memsz, *data + (*length - count) * memsz, count * memsz);\n}",
                "original_rust_code": "pub fn vec_swapsplice_(\n    mut data: Ptr<Ptr<u8>>,\n    mut length: Ptr<i32>,\n    mut capacity: Ptr<i32>,\n    mut memsz: i32,\n    mut start: i32,\n    mut count: i32\n) {\n    let _ = capacity;\n    c_memmove!(\n        (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n        (data.cast::<Ptr<u8>>() + (*length - count) * memsz).cast(),\n        count * memsz\n    );\n}",
                "optimized_rust_code": "pub fn vec_swapsplice_(\n    mut data: Ptr<Ptr<u8>>,\n    mut length: Ptr<i32>,\n    mut capacity: Ptr<i32>,\n    mut memsz: i32,\n    mut start: i32,\n    mut count: i32\n) {\n    let _ = capacity;\n    c_memmove!(\n        (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n        (data.cast::<Ptr<u8>>() + (*length - count) * memsz).cast(),\n        count * memsz\n    );\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066891809)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:50\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n   |                                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast::<T>(),\n   |                                                      +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066892109)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:50\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast(),\n   |                                                  ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |         (data.cast::<Ptr<u8>>() + start * memsz).cast::<T>(),\n   |                                                      +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void vec_swap_(char **data, int *length, int *capacity, int memsz, int idx1, int idx2)\n{\n    unsigned char *a, *b, tmp;\n    int count;\n    (void)length;\n    (void)capacity;\n    if (idx1 == idx2)\n        return;\n    a = (unsigned char *)*data + idx1 * memsz;\n    b = (unsigned char *)*data + idx2 * memsz;\n    count = memsz;\n    while (count--)\n    {\n        tmp = *a;\n        *a = *b;\n        *b = tmp;\n        a++, b++;\n    }\n}",
                "original_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz).cast();\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "optimized_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz).cast();\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066892251)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:27\n   |\n45 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz).cast();\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066892563)\nerror[E0282]: type annotations needed\n  --> src/src/vec_c.rs:45:27\n   |\n45 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz).cast();\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n45 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz).cast();\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    }
}
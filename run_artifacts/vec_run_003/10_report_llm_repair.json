{
    "macro": {
        "all_cnt": 2,
        "passed_cnt": 2,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 26,
        "passed_cnt": 20,
        "pass_rate": 0.7692307692307693,
        "messages": [
            {
                "c_code": "#define vec_t(T)                                                                                                       \\\n    struct                                                                                                             \\\n    {                                                                                                                  \\\n        T *data;                                                                                                       \\\n        int length, capacity;                                                                                          \\\n    }",
                "original_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_t {\n    ($t:ty) => {\n        struct Vec {\n            data: Ptr<$t>,\n            length: i32,\n            capacity: i32,\n        }\n    };\n}\npub(crate) use vec_t;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066947813)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066947813)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:41:1\n   |\n41 | pub(crate) macro_rules! vec_t {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n41 - pub(crate) macro_rules! vec_t {\n41 + #[macro_export] macro_rules! vec_t {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_deinit(v) (free((v)->data), vec_init(v))",
                "original_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "optimized_rust_code": "pub(crate) macro_rules! vec_deinit {\n    ($v:expr) => {\n        unsafe {\n            free($v.data.cast::<VoidPtr>());\n        }\n        vec_init($v);\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066948100)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066948100)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n  --> src/src/vec_h.rs:50:1\n   |\n50 | pub(crate) macro_rules! vec_deinit {\n   | ^^^^^^^^^^\n   |\nhelp: try exporting the macro\n   |\n50 - pub(crate) macro_rules! vec_deinit {\n50 + #[macro_export] macro_rules! vec_deinit {\n   |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_truncate(v, len) ((v)->length = (len) < (v)->length ? (len) : (v)->length)",
                "original_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        $v.cast().length = if $len < $v.cast().length { $len } else { $v.cast().length };\n    };\n}\npub(crate) use vec_truncate;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_truncate {\n    ($v:expr, $len:expr) => {\n        $v.cast().length = if $len < $v.cast().length { $len } else { $v.cast().length };\n    };\n}\npub(crate) use vec_truncate;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066949246)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:119:1\n    |\n119 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n119 - pub(crate) macro_rules! vec_truncate {\n119 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066949246)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:119:1\n    |\n119 | pub(crate) macro_rules! vec_truncate {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n119 - pub(crate) macro_rules! vec_truncate {\n119 + #[macro_export] macro_rules! vec_truncate {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_pusharr(v, arr, count)                                                                                     \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        int i__, n__ = (count);                                                                                        \\\n        if (vec_reserve_po2_(vec_unpack_(v), (v)->length + n__) != 0)                                                  \\\n            break;                                                                                                     \\\n        for (i__ = 0; i__ < n__; i__++)                                                                                \\\n        {                                                                                                              \\\n            (v)->data[(v)->length++] = (arr)[i__];                                                                     \\\n        }                                                                                                              \\\n    } while (0)",
                "original_rust_code": "pub(crate) macro_rules! vec_pusharr {\n    ($v:expr, $arr:expr, $count:expr) => {\n        let mut i__: i32;\n        let n__: i32 = $count;\n\n        if vec_reserve_po2_(vec_unpack_($v.cast()), $v.length + n__) != 0 {\n            break;\n        }\n\n        for i__ in 0..n__ {\n            let idx = $v.length;\n            $v.data[idx] = $arr[i__] as u8;\n            $v.length = $v.length.plus_plus();\n        }\n    }\n}\npub(crate) use vec_pusharr;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_pusharr {\n    ($v:expr, $arr:expr, $count:expr) => {\n        let mut i__: i32;\n        let n__: i32 = $count;\n\n        if vec_reserve_po2_(vec_unpack_($v.cast()), $v.length + n__) != 0 {\n            break;\n        }\n\n        for i__ in 0..n__ {\n            let idx = $v.length;\n            $v.data[idx] = $arr[i__] as u8;\n            $v.length = $v.length.plus_plus();\n        }\n    }\n}\npub(crate) use vec_pusharr;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066950124)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:147:1\n    |\n147 | pub(crate) macro_rules! vec_pusharr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n147 - pub(crate) macro_rules! vec_pusharr {\n147 + #[macro_export] macro_rules! vec_pusharr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066950124)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:147:1\n    |\n147 | pub(crate) macro_rules! vec_pusharr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n147 - pub(crate) macro_rules! vec_pusharr {\n147 + #[macro_export] macro_rules! vec_pusharr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_remove(v, val)                                                                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        int idx__;                                                                                                     \\\n        vec_find(v, val, idx__);                                                                                       \\\n        if (idx__ != -1)                                                                                               \\\n            vec_splice(v, idx__, 1);                                                                                   \\\n    } while (0)",
                "original_rust_code": "pub(crate) macro_rules! vec_remove {\n    ($v:expr, $val:expr) => {\n        let mut idx__: i32;\n        vec_find($v.cast(), $val.cast(), idx__.cast());\n        if idx__ != -1 {\n            vec_splice($v.cast(), idx__.cast(), 1.cast());\n        }\n    };\n}\npub(crate) use vec_remove;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_remove {\n    ($v:expr, $val:expr) => {\n        let mut idx__: i32;\n        vec_find($v.cast(), $val.cast(), idx__.cast());\n        if idx__ != -1 {\n            vec_splice($v.cast(), idx__.cast(), 1.cast());\n        }\n    };\n}\npub(crate) use vec_remove;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066950576)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:170:1\n    |\n170 | pub(crate) macro_rules! vec_remove {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n170 - pub(crate) macro_rules! vec_remove {\n170 + #[macro_export] macro_rules! vec_remove {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066950576)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:170:1\n    |\n170 | pub(crate) macro_rules! vec_remove {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n170 - pub(crate) macro_rules! vec_remove {\n170 + #[macro_export] macro_rules! vec_remove {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "#define vec_foreach_ptr(v, var, iter)                                                                                  \\\n    if ((v)->length > 0)                                                                                               \\\n        for ((iter) = 0; (iter) < (v)->length && (((var) = &(v)->data[(iter)]), 1); ++(iter))",
                "original_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            let mut iter = 0;\n            while iter < $v.length {\n                $var = c_ref!($v.data[iter]);\n                iter = iter.plus_plus();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "optimized_rust_code": "pub(crate) macro_rules! vec_foreach_ptr {\n    ($v:expr, $var:expr, $iter:expr) => {\n        if $v.length > 0 {\n            let mut iter = 0;\n            while iter < $v.length {\n                $var = c_ref!($v.data[iter]);\n                iter = iter.plus_plus();\n            }\n        }\n    };\n}\npub(crate) use vec_foreach_ptr;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066951179)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:202:1\n    |\n202 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n202 - pub(crate) macro_rules! vec_foreach_ptr {\n202 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066951179)\nerror: can't qualify macro_rules invocation with `pub(crate)`\n   --> src/src/vec_h.rs:202:1\n    |\n202 | pub(crate) macro_rules! vec_foreach_ptr {\n    | ^^^^^^^^^^\n    |\nhelp: try exporting the macro\n    |\n202 - pub(crate) macro_rules! vec_foreach_ptr {\n202 + #[macro_export] macro_rules! vec_foreach_ptr {\n    |\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "definition": {
        "all_cnt": 6,
        "passed_cnt": 5,
        "pass_rate": 0.8333333333333334,
        "messages": [
            {
                "c_code": "typedef vec_t(double) vec_double_t;",
                "original_rust_code": "pub type VecDoubleT = fn(f64) -> VecT;",
                "optimized_rust_code": "pub type VecDoubleT = fn(f64) -> VecT;",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066952230)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:34\n    |\n27  | pub type VecDoubleT = fn(f64) -> VecT;\n    |                                  ^^^^ help: a struct with a similar name exists: `Vec`\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769066952230)\nerror[E0412]: cannot find type `VecT` in this scope\n   --> src/src/vec_h.rs:27:34\n    |\n27  | pub type VecDoubleT = fn(f64) -> VecT;\n    |                                  ^^^^ help: a struct with a similar name exists: `Vec`\n    |\n   ::: /home/poil/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:414:1\n    |\n414 | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    | ------------------------------------------------------------------------------------------------ similarly named struct `Vec` defined here\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    },
    "dummy_function": {
        "all_cnt": 8,
        "passed_cnt": 8,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 8,
        "passed_cnt": 7,
        "pass_rate": 0.875,
        "messages": [
            {
                "c_code": "void vec_swap_(char **data, int *length, int *capacity, int memsz, int idx1, int idx2)\n{\n    unsigned char *a, *b, tmp;\n    int count;\n    (void)length;\n    (void)capacity;\n    if (idx1 == idx2)\n        return;\n    a = (unsigned char *)*data + idx1 * memsz;\n    b = (unsigned char *)*data + idx2 * memsz;\n    count = memsz;\n    while (count--)\n    {\n        tmp = *a;\n        *a = *b;\n        *b = tmp;\n        a++, b++;\n    }\n}",
                "original_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz);\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "optimized_rust_code": "pub fn vec_swap_(mut data: Ptr<Ptr<u8>>, mut length: Ptr<i32>, mut capacity: Ptr<i32>, mut memsz: i32, mut idx1: i32, mut idx2: i32) {\n    let _ = length;\n    let _ = capacity;\n    if idx1 == idx2 {\n        return;\n    }\n    let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n    let b: Ptr<u8> = data.cast().add(idx2 * memsz);\n    let mut count: i32 = memsz;\n    while count > 0 {\n        let tmp: u8 = *a;\n        *a = *b;\n        *b = tmp;\n        a = a.suffix_plus_plus();\n        b = b.suffix_plus_plus();\n        count = count.suffix_minus_minus();\n    }\n}",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769067687620)\nerror[E0282]: type annotations needed\n   --> src/src/vec_c.rs:109:27\n    |\n109 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n    |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n109 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz);\n    |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/poil/\u684c\u9762/github/EvoC2rust_work/EvoC2rust/.tmp/created_project/vec_run_003_1769067874297)\nerror[E0282]: type annotations needed\n   --> src/src/vec_c.rs:109:27\n    |\n109 |     let a: Ptr<u8> = data.cast().add(idx1 * memsz);\n    |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n109 |     let a: Ptr<u8> = data.cast::<T>().add(idx1 * memsz);\n    |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    }
}